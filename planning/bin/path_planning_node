#! /usr/bin/env python
from rrt_dubins.rrt_cleaning_dubins import RRT
import numpy as np

import rospy
from nav_msgs.msg import Odometry, OccupancyGrid, Path, GridCells
from geometry_msgs.msg import Pose, Point, PoseStamped
from tf.transformations import euler_from_quaternion, quaternion_from_euler
import matplotlib.pyplot as plt
import timeit


class Server:
    def __init__(self):
        self._odom = None
        self._map = None
        self._goal = None
        self._obstacles = None
        self._final_path = None

        self.CURVATURE = 0.3
        self.ROBOT_WIDTH = 0.5
        self.ROBOT_HEIGHT = 0.7

    def odometry_callback(self, data):
        # rospy.loginfo("Odom recieved")
        self._odom = data

    def obstacles_callback(self, data):
        # rospy.loginfo("Odom recieved")
        self._obstacles = data

    def map_callback(self, data):
        # rospy.loginfo("Map recieved")
        self._map = data

    def goal_callback(self, data):
        # rospy.loginfo("Goal recieved")
        self._goal = data

    def get_map(self):
        return self._map

    def get_odometry(self):
        return self._odom

    def get_obstacles(self):
        return self._obstacles

    def get_goal(self):
        return self._goal


def main():
    server = Server()
    rospy.init_node('rrt_path_planner', anonymous=True)

    rospy.Subscriber("odom", Odometry, server.odometry_callback)
    rospy.Subscriber("global_map", OccupancyGrid, server.map_callback)
    rospy.Subscriber("move_base_simple/goal", PoseStamped, server.goal_callback)
    rospy.Subscriber("obstacles", GridCells, server.obstacles_callback)

    pub = rospy.Publisher('path', Path, queue_size=10)
    rate = rospy.Rate(100)  # 10hz

    while not rospy.is_shutdown():
        current_position = server.get_odometry()
        goal_position = server.get_goal()
        current_map = server.get_map()
        obstacles = server.get_obstacles()
        if current_position and goal_position and current_map:
            cur_orientation_list = [current_position.pose.pose.orientation.x,
                                    current_position.pose.pose.orientation.y,
                                    current_position.pose.pose.orientation.z,
                                    current_position.pose.pose.orientation.w]
            goal_orientation_list = [goal_position.pose.orientation.x,
                                     goal_position.pose.orientation.y,
                                     goal_position.pose.orientation.z,
                                     goal_position.pose.orientation.w]

            # rospy.loginfo("True")
            start = [current_position.pose.pose.position.x,
                     current_position.pose.pose.position.y,
                     euler_from_quaternion(cur_orientation_list)[2]]
            goal = [goal_position.pose.position.x,
                    goal_position.pose.position.y,
                    euler_from_quaternion(goal_orientation_list)[2]]

            # obstacleList = [(cell.x, cell.y, server.ROBOT_WIDTH / 2) for cell in obstacles.cells]
            # obstacleList = obstacles.cells

            # obstacleList = map(lambda cell: (cell.x, cell.y, server.ROBOT_WIDTH / 2), obstacles.cells)
            # obstacleList = obstacles.cells
            obstacleList = current_map
            rand_area = [-current_map.info.height * 0.04, current_map.info.height* 0.04]
            # rand_area = [-10, 10]
            rrt = RRT(start,
                      goal,
                      rand_area=rand_area,
                      obstacle_list=obstacleList)

            starttime = timeit.default_timer()
            path = rrt.planning()
            print('Время', timeit.default_timer() - starttime, 'Найден:', bool(path))


            # print(path)
            path_rviz = Path()
            if path:
                for x, y, yaw in path:
                    p = PoseStamped()
                    p.header = server.get_odometry().header
                    p.pose.position.x = x
                    p.pose.position.y = y
                    result = quaternion_from_euler(0, 0, yaw)
                    p.pose.orientation.x = result[0]
                    p.pose.orientation.y = result[1]
                    p.pose.orientation.z = result[2]
                    p.pose.orientation.w = result[3]

                    path_rviz.poses.append(p)

                path_rviz.header = server.get_odometry().header
                path_rviz.header.stamp = rospy.Time.now()
                pub.publish(path_rviz)

            # if path:
            #     rrt.draw_graph()
            #
            #     plt.plot([x for (x, y, z) in path], [y for (x, y, z) in path], '-r')
            #     plt.plot([x.x for x in rrt.new_node_list], [y.y for y in rrt.new_node_list], '-v')
            #
            #     plt.grid(True)
            #     plt.pause(0.01)  # Need for Mac
            #     plt.show()
        rate.sleep()
        # rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
