#! /usr/bin/env python
from rrt_dubins.rrt_cleaning_dubins import RRT
import numpy as np

import rospy
from nav_msgs.msg import Odometry, OccupancyGrid, Path
from geometry_msgs.msg import Pose, Point, PoseStamped
from tf.transformations import euler_from_quaternion, quaternion_from_euler
import matplotlib.pyplot as plt


class Server:
    def __init__(self):
        self._odom = None
        self._map = None
        self._goal = None
        self._final_path = None

        self.CURVATURE = 0.3
        self.ROBOT_WIDTH = 0.5
        self.ROBOT_HEIGHT = 0.7

    def odometry_callback(self, data):
        # rospy.loginfo("Odom recieved")
        self._odom = data

    def map_callback(self, data):
        # rospy.loginfo("Map recieved")
        self._map = data

    def goal_callback(self, data):
        # rospy.loginfo("Goal recieved")
        self._goal = data

    def get_map(self):
        return self._map

    def get_odometry(self):
        return self._odom

    def get_goal(self):
        return self._goal


def main():
    server = Server()
    rospy.init_node('rrt_path_planner', anonymous=True)

    rospy.Subscriber("odom", Odometry, server.odometry_callback)
    rospy.Subscriber("global_map", OccupancyGrid, server.map_callback)
    rospy.Subscriber("move_base_simple/goal", PoseStamped, server.goal_callback)

    pub = rospy.Publisher('path', Path, queue_size=10)
    rate = rospy.Rate(10)  # 10hz


    while not rospy.is_shutdown():
        current_position = server.get_odometry()
        goal_position = server.get_goal()
        current_map = server.get_map()
        if current_position and goal_position:
            cur_orientation_list = [current_position.pose.pose.orientation.x,
                                    current_position.pose.pose.orientation.y,
                                    current_position.pose.pose.orientation.z,
                                    current_position.pose.pose.orientation.w]
            goal_orientation_list = [goal_position.pose.orientation.x,
                                     goal_position.pose.orientation.y,
                                     goal_position.pose.orientation.z,
                                     goal_position.pose.orientation.w]

            # rospy.loginfo("True")
            start = [current_position.pose.pose.position.x,
                     current_position.pose.pose.position.y,
                     euler_from_quaternion(cur_orientation_list)[2]]
            goal = [goal_position.pose.position.x,
                    goal_position.pose.position.y,
                    euler_from_quaternion(goal_orientation_list)[2]]

            obstacleList = []

            # rand_area = [current_map.info.height, current_map.info.width]
            rand_area = [-10, 10]
            rrt = RRT(start,
                      goal,
                      rand_area=rand_area,
                      obstacle_list=obstacleList)
            path = rrt.planning()
            # print(path)
            path_rviz = Path()
            for x, y, yaw in path:
                p = PoseStamped()
                p.header = server.get_odometry().header
                p.pose.position.x = x
                p.pose.position.y = y
                result = quaternion_from_euler(0, 0,  yaw)
                p.pose.orientation.x = result[0]
                p.pose.orientation.y = result[1]
                p.pose.orientation.z = result[2]
                p.pose.orientation.w = result[3]

                path_rviz.poses.append(p)
            path_rviz.header = server.get_odometry().header
            path_rviz.header.stamp = rospy.Time.now()
            pub.publish(path_rviz)

            # if path:
            #     rrt.draw_graph()
            #
            #     plt.plot([x for (x, y) in path], [y for (x, y) in path], '-r')
            #     plt.plot([x.x for x in rrt.new_node_list], [y.y for y in rrt.new_node_list], '-v')
            #
            #     plt.grid(True)
            #     plt.pause(0.01)  # Need for Mac
            #     plt.show()
        rate.sleep()
        # rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass

