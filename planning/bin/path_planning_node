#! /usr/bin/env python
from rrt_dubins.rrt_cleaning_dubins import RRT
import numpy as np

import rospy
from nav_msgs.msg import Odometry, OccupancyGrid, Path
from geometry_msgs.msg import Pose, Point, PoseStamped
from tf.transformations import euler_from_quaternion, quaternion_from_euler
import matplotlib.pyplot as plt


class Server:
    def __init__(self):
        self._odom = None
        self._map = None
        self._goal = None
        self._final_path = None

        self.CURVATURE = 0.3
        self.ROBOT_WIDTH = 0.5
        self.ROBOT_HEIGHT = 0.7

    def odometry_callback(self, data):
        # rospy.loginfo("Odom recieved")
        self._odom = data

    def map_callback(self, data):
        # rospy.loginfo("Map recieved")
        self._map = data

    def goal_callback(self, data):
        # rospy.loginfo("Goal recieved")
        self._goal = data

    def get_map(self):
        return self._map

    def get_odometry(self):
        return self._odom

    def get_goal(self):
        return self._goal


def main():
    server = Server()
    rospy.init_node('rrt_path_planner', anonymous=True)

    rospy.Subscriber("odom", Odometry, server.odometry_callback)
    rospy.Subscriber("global_map", OccupancyGrid, server.map_callback)
    rospy.Subscriber("move_base_simple/goal", PoseStamped, server.goal_callback)

    # pub = rospy.Publisher('chatter', String, queue_size=10)
    rate = rospy.Rate(10)  # 10hz

    while not rospy.is_shutdown():
        current_position = server.get_odometry()
        goal_position = server.get_goal()
        current_map = server.get_map()
        if current_position and current_map and goal_position:
            cur_orientation_list = [current_position.pose.pose.orientation.x,
                                    current_position.pose.pose.orientation.y,
                                    current_position.pose.pose.orientation.z,
                                    current_position.pose.pose.orientation.w]
            goal_orientation_list = [goal_position.pose.orientation.x,
                                     goal_position.pose.orientation.y,
                                     goal_position.pose.orientation.z,
                                     goal_position.pose.orientation.w]

            # rospy.loginfo("True")
            start = [current_position.pose.pose.position.x,
                     current_position.pose.pose.position.y,
                     euler_from_quaternion(cur_orientation_list)[2]]
            goal = [goal_position.pose.position.x,
                    goal_position.pose.position.y,
                    euler_from_quaternion(goal_orientation_list)[2]]

            obstacleList = []

            rand_area = [current_map.info.height, current_map.info.width]
            rrt = RRT(start,
                      goal,
                      rand_area=rand_area,
                      obstacle_list=obstacleList)
            path = rrt.planning()
            # print(path)
            if path:
                rrt.draw_graph()

                plt.plot([x for (x, y) in path], [y for (x, y) in path], '-r')
                plt.plot([x.x for x in rrt.new_node_list], [y.y for y in rrt.new_node_list], '-v')

                plt.grid(True)
                plt.pause(0.01)  # Need for Mac
                plt.show()
        rate.sleep()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass

